{
  "hash": "abc49396b2703f385bc08f32041e091c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Logistic regression\"\nsubtitle: \"Lecture 19\"\ndate: \"March 28, 2024\"\nformat: \n  revealjs:\n    footer: \"[üîó sta199-s24.github.io](https://sta199-s24.github.io/) &nbsp;¬∑&nbsp; [‚ùì Ask on Ed](https://edstem.org/us/courses/50730)\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# Warm up\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## While you wait for class to begin...\n\n::: nonincremental\nAny questions from prepare materials?\n:::\n\n\n\n```{=html}\n<iframe allowfullscreen frameborder=\"0\" height=\"100%\" mozallowfullscreen style=\"min-width: 500px; min-height: 355px\" src=\"https://app.wooclap.com/STA199S24?from=status-bar?\" width=\"100%\"></iframe>\n```\n\n\n## Announcements\n\n-   ...\n\n# From last time\n\n## Recap: `ae-13-modeling-loans`\n\n-   What is the practical difference between a model with parallel and non-parallel lines?\n\n-   What is the definition of R-squared?\n\n-   Why do we choose models based on adjusted R-squared and not R-squared?\n\n## Predict interest rate...\n\nfrom credit utilization and homeownership\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate_util_home_fit <- linear_reg() |>\n  fit(interest_rate ~ credit_util + homeownership, data = loans)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(rate_util_home_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 5\n  term                  estimate std.error statistic   p.value\n  <chr>                    <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)              9.93      0.140    70.8   0        \n2 credit_util              5.34      0.207    25.7   2.20e-141\n3 homeownershipMortgage    0.696     0.121     5.76  8.71e-  9\n4 homeownershipOwn         0.128     0.155     0.827 4.08e-  1\n```\n\n\n:::\n:::\n\n\n\n## Intercept {.smaller}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 5\n  term                  estimate std.error statistic   p.value\n  <chr>                    <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)              9.93      0.140    70.8   0        \n2 credit_util              5.34      0.207    25.7   2.20e-141\n3 homeownershipMortgage    0.696     0.121     5.76  8.71e-  9\n4 homeownershipOwn         0.128     0.155     0.827 4.08e-  1\n```\n\n\n:::\n:::\n\n\n\n-   Intercept: Loan applicants who rent and have 0 credit utilization are predicted to receive an interest rate of 9.93%, on average.\n\n## Slopes {.smaller}\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 √ó 5\n  term                  estimate std.error statistic   p.value\n  <chr>                    <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)              9.93      0.140    70.8   0        \n2 credit_util              5.34      0.207    25.7   2.20e-141\n3 homeownershipMortgage    0.696     0.121     5.76  8.71e-  9\n4 homeownershipOwn         0.128     0.155     0.827 4.08e-  1\n```\n\n\n:::\n:::\n\n\n\n::: incremental\n-   All else held constant, for each additional percent credit utilization is higher, interest rate is predicted to be higher, on average, by 0.0534%.\n\n-   All else held constant, the model predicts that loan applicants who have a mortgage for their home receive 0.696% higher interest rate than those who rent their home, on average.\n\n-   All else held constant, the model predicts that loan applicants who own their home receive 0.128% higher interest rate than those who rent their home, on average.\n:::\n\n# Transformations\n\n## Predict log(interest rate)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrate_log_cc_fit <- linear_reg() |>\n  fit(log(interest_rate) ~ credit_checks, data = loans)\n\ntidy(rate_log_cc_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 √ó 5\n  term          estimate std.error statistic  p.value\n  <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)     2.39     0.00512     468.  0       \n2 credit_checks   0.0236   0.00166      14.2 2.39e-45\n```\n\n\n:::\n:::\n\n\n\n## Model\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 √ó 5\n  term          estimate std.error statistic  p.value\n  <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)     2.39     0.00512     468.  0       \n2 credit_checks   0.0236   0.00166      14.2 2.39e-45\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n$$\n\\widehat{log(interest~rate)} = 2.37 + 0.00388 \\times credit~checks\n$$\n\n## Slope\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 √ó 5\n  term          estimate std.error statistic  p.value\n  <chr>            <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)     2.39     0.00512     468.  0       \n2 credit_checks   0.0236   0.00166      14.2 2.39e-45\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nFor each additional credit check, log of interest rate is predicted to be higher, on average, by 0.0236%.\n\n## Slope {.smaller}\n\n$$\nlog(interest~rate_{x+1}) - log(interest~rate_{x}) =  0.0236\n$$\n\n. . .\n\n$$\nlog(\\frac{interest~rate_{x+1}}{interest~rate_{x}}) = 0.0236\n$$\n\n. . .\n\n$$\ne^{log(\\frac{interest~rate_{x+1}}{interest~rate_{x}})} = e^0.0236\n$$\n\n. . .\n\n$$\n\\frac{interest~rate_{x+1}}{interest~rate_{x}} = 1.024\n$$\n\n. . .\n\nFor each additional credit check, interest rate is predicted to be higher, on average, by **a factor of 1.024**.\n\n# Logistic regression\n\n## What is logistic regression?\n\n::: columns\n::: {.column width=\"50%\"}\n-   Similar to linear regression....\n    but\n\n-   Modeling tool when our response is categorical\n:::\n\n::: {.column width=\"50%\"}\n![](images/logistic.png){fig-align=\"center\"}\n:::\n:::\n\n## Modelling binary outcomes\n\n-   Variables with binary outcomes follow the **Bernouilli distribution**:\n\n    -   $y_i \\sim Bern(p)$\n\n    -   $p$: Probability of success\n\n    -   $1-p$: Probability of failure\n\n-   We can't model $y$ directly, so instead we model $p$\n\n## Linear model\n\n$$\np_i = \\beta_o + \\beta_1 \\times X_1 + \\cdots + \\epsilon\n$$\n\n-   But remember that $p$ must be between 0 and 1\n\n-   We need a **link function** that transforms the linear model to have an appropriate range\n\n## Logit link function\n\nThe **logit** function take values between 0 and 1 (probabilities) and maps them to values in the range negative infinity to positive infinity:\n\n$$\nlogit(p) = log \\bigg( \\frac{p}{1 - p} \\bigg)\n$$\n\n\n\n\n\n\n\n## This isn't exactly what we need though.....\n\n-   Recall, the goal is to take values between -$\\infty$ and $\\infty$ and map them to probabilities.\n\n-   We need the opposite of the link function... or the *inverse*\n\n-   Taking the inverse of the logit function will map arbitrary real values back to the range \\[0, 1\\]\n\n## Generalized linear model\n\n-   We model the logit (log-odds) of $p$ :\n\n$$\nlogit(p) = log \\bigg( \\frac{p}{1 - p} \\bigg) = \\beta_o + \\beta_1 \\times X1_i + \\cdots + \\epsilon \n$$\n\n-   Then take the inverse to obtain the predicted $p$:\n\n$$\np_i = \\frac{e^{\\beta_o + \\beta_1 \\times X1_i + \\cdots + \\epsilon}}{1 + e^{\\beta_o + \\beta_1 \\times X1_i + \\cdots + \\epsilon}}\n$$\n\n## A logistic model visualized\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](19-logistic-regression_files/figure-revealjs/unnamed-chunk-11-1.png){width=960}\n:::\n:::\n\n\n\n## Takeaways\n\n-   Generalized linear models allow us to fit models to predict non-continuous outcomes\n\n-   Predicting binary outcomes requires modeling the log-odds of success, where p = probability of success\n\n",
    "supporting": [
      "19-logistic-regression_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}