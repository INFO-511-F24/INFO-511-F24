---
title: "AE 11: Modelling loan interest rates"
subtitle: "Suggested answers"
categories: 
  - Application exercise
  - Answers
editor: visual
fig-width: 7
fig-asp: 0.618
jupyter: python3
execute:
  warning: false
  error: false
---

In this application exercise we will be studying loan interest rates.
The dataset is one you've come across before in your reading -- the dataset about loans from the peer-to-peer lender, Lending Club, from the **openintro** R package.
We will use **pandas** and **scikit-learn** for data exploration and modeling, respectively.

```{python}
#| label: load-packages
#| message: false

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import statsmodels.api as sm

loans = pd.read_csv('data/loans_full_schema.csv')
```

Before we use the dataset, we'll make a few transformations to it.

-   **Your turn:** Review the code below and write a summary of the data transformation pipeline.

1.  **Calculate Credit Utilization**:

    -   A new column `credit_util` is created by dividing the `total_credit_utilized` by the `total_credit_limit`.

2.  **Transform Bankruptcy Indicator**:

    -   The `public_record_bankrupt` column is converted into a binary categorical column `bankruptcy`, where `0` remains `0` and any other value is converted to `1`.

3.  **Convert Verified Income to Category**:

    -   The `verified_income` column is converted to a categorical data type.

4.  **Format and Order Homeownership**:

    -   The `homeownership` column is formatted to have title case (capitalizing the first letter of each word) and is converted to a categorical data type.

    -   The `homeownership` categories are ordered as "Rent", "Mortgage", and "Own".

5.  **Rename Column**:

    -   The column `inquiries_last_12m` is renamed to `credit_checks`.

6.  **Select Relevant Columns**:

    -   The dataset is filtered to keep only the columns `interest_rate`, `loan_amount`, `verified_income`, `debt_to_income`, `credit_util`, `bankruptcy`, `term`, `credit_checks`, `issue_month`, and `homeownership`.

```{python}
#| label: data-prep

loans['credit_util'] = loans['total_credit_utilized'] / loans['total_credit_limit']
loans['bankruptcy'] = loans['public_record_bankrupt'].apply(lambda x: 0 if x == 0 else 1).astype('category')
loans['verified_income'] = loans['verified_income'].astype('category')
loans['homeownership'] = loans['homeownership'].str.title().astype('category')
loans['homeownership'] = pd.Categorical(loans['homeownership'], categories=["Rent", "Mortgage", "Own"], ordered=True)
loans = loans.rename(columns={'inquiries_last_12m': 'credit_checks'})
loans = loans[['interest_rate', 'loan_amount', 'verified_income', 'debt_to_income', 'credit_util', 'bankruptcy', 'term', 'credit_checks', 'issue_month', 'homeownership']]

```

Here is a glimpse at the data:

```{python}
#| label: glimpse-loans

print(loans.info())
print(loans.describe())
```

# Get to know the data

-   **Your turn:** What is a typical interest rate in this dataset? What are some attributes of a typical loan and a typical borrower. Give yourself no more than 5 minutes for this exploration and share 1-2 findings.

```{python}
#| label: explore-loans
#| warning: false

fig, axs = plt.subplots(2, 2, figsize=(15, 10))
sns.histplot(loans['interest_rate'], bins=30, kde=True, ax=axs[0, 0])
axs[0, 0].set_title('Interest Rate Distribution')

sns.histplot(loans['loan_amount'], bins=30, kde=True, ax=axs[0, 1])
axs[0, 1].set_title('Loan Amount Distribution')

sns.countplot(x='term', data=loans, ax=axs[1, 0])
axs[1, 0].set_title('Term Distribution')

sns.countplot(x='issue_month', data=loans, ax=axs[1, 1])
axs[1, 1].set_title('Issue Month Distribution')

plt.tight_layout()
plt.show()

```

```{python}
#| label: explore-borrowers
#| warning: false

fig, axs = plt.subplots(3, 2, figsize=(15, 15))
sns.histplot(loans['credit_util'], bins=30, kde=True, ax=axs[0, 0])
axs[0, 0].set_title('Credit Utilization Distribution')

sns.countplot(x='verified_income', data=loans, ax=axs[0, 1])
axs[0, 1].set_title('Verified Income Distribution')

sns.histplot(loans['debt_to_income'], bins=30, kde=True, ax=axs[1, 0])
axs[1, 0].set_title('Debt to Income Distribution')

sns.countplot(x='bankruptcy', data=loans, ax=axs[1, 1])
axs[1, 1].set_title('Bankruptcy Distribution')

sns.countplot(x='credit_checks', data=loans, ax=axs[2, 0])
axs[2, 0].set_title('Credit Checks Distribution')

sns.countplot(x='homeownership', data=loans, ax=axs[2, 1])
axs[2, 1].set_title('Homeownership Distribution')

plt.tight_layout()
plt.show()
```

# Interest rate vs. credit utilization ratio

Python does not encode categories or handle missing values for you.
Linear regression models are incapable of handling either, so we will need to use one-hot encoding to encode categories and drop missing values.

**Hint**: Python also does not convert the one-hot encoded values to numerics...
so we must do this as well.

```{python}
X = loans[['credit_util', 'homeownership']]

X = pd.get_dummies(X, drop_first=True)

X = X.dropna()
X = X.replace([np.inf, -np.inf], np.nan).dropna()
X = X.astype(float)

y = loans.loc[X.index, 'interest_rate']
y = y.dropna()
```

The regression model for interest rate vs. credit utilization is as follows.

```{python}
#| label: rate-util-fit

X = sm.add_constant(X)
model = sm.OLS(y, X).fit()
print(model.summary2())
```

And here is the model visualized:

```{python}
#| label: rate-util-plot
#| warning: false

sns.scatterplot(x='credit_util', y='interest_rate', data=loans, alpha=0.5)
sns.lineplot(x=loans['credit_util'], y=model.predict(X), color='red')
plt.xlabel('Credit Utilization')
plt.ylabel('Interest Rate')
plt.title('Interest Rate vs. Credit Utilization')
plt.show()
```

-   **Your turn:** Interpret the intercept and the slope.

Intercept: Borrowers with 0 credit utilization are predicted, on average, to get an interest rate of 10.5%.

Slope: For each additional point credit utilization is higher, interest rate is predicted to be higher, on average, by 4.73%.

# Interest rate vs. homeownership

Next we predict interest rates from homeownership, which is a categorical predictor with three levels:

```{python}
homeownership_levels = loans['homeownership'].cat.categories
print(homeownership_levels)
```

-   **Demo:** Fit the linear regression model to predict interest rate from homeownership and display a summary of the model. Write the estimated model output below.

```{python}
#| label: rate-home-fit

X = pd.get_dummies(loans['homeownership'], drop_first=True)
X = X.astype(float)
X = sm.add_constant(X)
y = loans['interest_rate']
model = sm.OLS(y, X).fit()
print(model.summary2())
```

-   **Your turn:** Interpret each coefficient in context of the problem.

    -   Intercept: Loan applicants who rent are predicted to receive an interest rate of 12.9%, on average.

    -   Slopes:

        -   The model predicts that loan applicants who have a mortgage for their home receive 0.866% lower interest rate than those who rent their home, on average.

        -   The model predicts that loan applicants who own their home receive 0.611% lower interest rate than those who rent their home, on average.

# Interest rate vs. credit utilization and homeownership

## Main effects model

-   **Demo:** Fit a model to predict interest rate from credit utilization and homeownership, **without** an interaction effect between the two predictors. Display the summary output and write out the estimated regression equation.

```{python}
#| label: rate-util-home-fit

X = loans[['credit_util']].join(pd.get_dummies(loans['homeownership'], drop_first=True)).astype(float)
X = sm.add_constant(X)
y = loans['interest_rate']

data = pd.concat([X, y], axis=1)
data = data.replace([np.inf, -np.inf], np.nan).dropna()

X = data.drop(columns='interest_rate')
y = data['interest_rate']

main_effects_model = sm.OLS(y, X).fit()
print(model.summary2())
```

$$
\widehat{interest~rate} = 9.93 + 5.34 \times credit~util + 0.696 \times Mortgage + 0.128 \times Own
$$

-   **Demo:** Write the estimated regression equation for loan applications from each of the homeownership groups separately.
    -   Rent: $\widehat{interest~rate} = 9.93 + 5.34 \times credit~util$
    -   Mortgage: $\widehat{interest~rate} = 10.626 + 5.34 \times credit~util$
    -   Own: $\widehat{interest~rate} = 10.058 + 5.34 \times credit~util$
-   **Question:** How does the model predict the interest rate to vary as credit utilization varies for loan applicants with different homeownership status. Are the rates the same or different?

The same.

## Interaction effects model

-   **Demo:** Fit a model to predict interest rate from credit utilization and homeownership, **with** an interaction effect between the two predictors. Display the summary output and write out the estimated regression equation.

```{python}
#| label: rate-util-home-int-fit

X = loans[['credit_util']].join(pd.get_dummies(loans['homeownership'], drop_first=True)).astype(float)
X['credit_util_Mortgage'] = X['credit_util'] * X['Mortgage']
X['credit_util_Own'] = X['credit_util'] * X['Own']
X = sm.add_constant(X)
y = loans['interest_rate']

data = pd.concat([X, y], axis=1)
data = data.replace([np.inf, -np.inf], np.nan).dropna()

X = data.drop(columns='interest_rate')
y = data['interest_rate']

interaction_model = sm.OLS(y, X).fit()
print(model.summary2())
```

$$
\widehat{interest~rate} = 9.44 + 6.20 \times credit~util + 1.39 \times Mortgage + 0.697 \times Own - 1.64 \times credit_util:Mortgage - 1.06 \times credit_util:Own
$$

-   **Demo:** Write the estimated regression equation for loan applications from each of the homeownership groups separately.
    -   Rent: $\widehat{interest~rate} = 9.44 + 6.20 \times credit~util$
    -   Mortgage: $\widehat{interest~rate} = 10.83 + 4.56 \times credit~util$
    -   Own: $\widehat{interest~rate} = 10.137 + 5.14 \times credit~util$
-   **Question:** How does the model predict the interest rate to vary as credit utilization varies for loan applicants with different homeownership status. Are the rates the same or different?

Different.

## Choosing a model

Rule of thumb: **Occam's Razor** - Don't overcomplicate the situation!
We prefer the *simplest* best model.

```{python}
#| label: glance

print(main_effects_model.summary2())
print(interaction_model.summary2())

print("Main Effects Model Adjusted R-squared:", main_effects_model.rsquared_adj)
print("Interaction Effects Model Adjusted R-squared:", interaction_model.rsquared_adj)
```

-   **Review:** What is R-squared? What is adjusted R-squared?

R-squared is the percent variability in the response that is explained by our model.
(Can use when models have same number of variables for model selection)

Adjusted R-squared is similar, but has a penalty for the number of variables in the model.
(Should use for model selection when models have different numbers of variables).

-   **Question:** Based on the adjusted $R^2$s of these two models, which one do we prefer?

The interaction effects model, though just barely.

# Another model to consider

-   **Your turn:** Let's add one more model to the variable -- issue month. Should we add this variable to the interaction effects model from earlier?

```{python}
#| label: new-fit

X = loans[['credit_util']].join(pd.get_dummies(loans['homeownership'], drop_first=True)).join(pd.get_dummies(loans['issue_month'], drop_first=True)).astype(float)
X['credit_util_Mortgage'] = X['credit_util'] * X['Mortgage']
X['credit_util_Own'] = X['credit_util'] * X['Own']
X = sm.add_constant(X)
y = loans['interest_rate']

data = pd.concat([X, y], axis=1)
data = data.replace([np.inf, -np.inf], np.nan).dropna()

X = data.drop(columns='interest_rate')
y = data['interest_rate']

new_model = sm.OLS(y, X).fit()
print(new_model.summary2())

print("New Model Adjusted R-squared:", new_model.rsquared_adj)
```

No, the adjusted R-squared goes down.
